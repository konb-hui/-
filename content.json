{"meta":{"title":"konb的博客","subtitle":"","description":"","author":"konb","url":"https://konb-hui.github.io/blog","root":"/blog/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"12-09","excerpt":""},{"title":"about","text":"","path":"about/index.html","date":"12-09","excerpt":""},{"title":"search","text":"","path":"search/index-1.html","date":"12-09","excerpt":""},{"title":"search","text":"","path":"search/index-3.html","date":"12-09","excerpt":""},{"title":"search","text":"","path":"search/index-2.html","date":"12-09","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"12-09","excerpt":""},{"title":"search","text":"","path":"search/index-4.html","date":"12-09","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"12-09","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"12-09","excerpt":""}],"posts":[{"title":"如何创建一个chatGPT的微信机器人","text":"最近chatGPT还是比较火，也因为也比较感兴趣且刚好在github上看到一个把chatGPT做出微信机器人的项目，然后就去了解了下怎么弄，然后就出了这个教程把整个过程总结一下。 一、准备api key1.注册openAI账号 准备一个邮箱 需要代理或者VPN才能进入官网注册，而且需要是chatGPT支持的国家 需要一个国外的手机号，也需要是chatGPT支持的国家，可以去这里购买，也需要注册，支持支付宝，一次至少充值1美元，1美元最便宜的可以买两个号码，不过一定要先确认好chatGPT支不支持该国家 以上都准备好了，就可以直接注册了，然后此时可以直接去这里体验官网的chatGPT，如果想继续创建自己的应用就往下2.创建api key点击这里创建api key，如下图所示二、创建应用1.使用github项目该项目是nodeJS，fork或者直接拉到本地都行，如果想部署在外网就fork，部署本地就拉到本地，不过都需要准备好代理地址该项目默认提供了两种方式，如下图 chatgpt就是连接到chatGPT3.5，也是我们目前的目的，不过他用的不是官网的接口，也是一个GitHub的开源项目，该项目提供了两种接口，对比如下第一种是收费的，1000token/0.002美元,这种也是我们目前用的，因为注册openAI会送18美元，所以个人可以用很久了第二种免费的，但是用这个项目下的代理会封号，第一个失效，第二个很慢且会被封号，亲身经历 openAI是官网提供的另一个AI模型，没有chatGPT强也挺不错了，且不需要代理，可以直接使用2.修改代码因为是调的接口，即使运行应用的机器跑了代理也不会起效，所以我们要修改请求方式，修改为如下代码就行12345678910111213141516const api = new ChatGPTAPI(&#123; apiKey: env.OPENAI_API_KEY, debug: false, fetch: (url, options = &#123;&#125;) =&gt; &#123; const defaultOptions = &#123; agent: proxy(&quot;代理地址&quot;), &#125;; const mergedOptions = &#123; ...defaultOptions, ...options, &#125;; return nodeFetch(url, mergedOptions); &#125;,&#125;); 当然也可以使用官方提供的接口，去该地址, 官方提供了三种方式，不过需要自己探索代理请求的方法为了保证chatGPT可以理解上下文进行对话，需要带上每次请求接口返回的id,代码如下所示，response是chatGPT的回复12345678910let res = await oraPromise( api.sendMessage(content, &#123; parentMessageId: id &#125;), &#123; text: content &#125;)map.set(name, res.id)const response = res.detail.choices[0].message.content 3.修改配置这个参照该项目的readme文件就好4.部署 本地部署，很简单，参照作者的教程就好 外网部署，这里我一定要推荐railway,该网站可以使用github登录，然后直接选择自己仓库的项目就可以一键部署，每个月会送5美元，个人使用完全足够了，没有域名的，部署完成后记得点击setting的这个地方生成一个域名，这个虽然简单，但是部署外网有风险，因为api key暴露在外网，要小心被被人薅了羊毛三、备用因为微信使用程序自动回复，会有风险被封号，切记使用小号，切记使用小号，切记使用小号，且不要加太多人使用，否则容易被封，自己用应该问题不大，不过备用方案是用网站，我目前还在开发一个双服务器的网站版的系统，一个外网java服务器进行消息转发，一个nodeJS服务器在本地请求chatGPT，前端就是一个聊天框，java服务器代码已上传，点击前往,后续会把nodeJS服务端代码和前端代码上传。","path":"2023/03/22/chatgpt-to-wechat/chatgpt-to-wechat/","date":"03-22","excerpt":"","tags":[{"name":"chatGPT","slug":"chatGPT","permalink":"https://konb-hui.github.io/blog/tags/chatGPT/"},{"name":"[object Object]","slug":"object-Object","permalink":"https://konb-hui.github.io/blog/tags/object-Object/"},{"name":"成神之路","slug":"成神之路","permalink":"https://konb-hui.github.io/blog/tags/%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/"}]},{"title":"常用排序算法","text":"因为一直来说没有去手写过这些排序算法，只是了解原理，所以将一些常用的算法自己手写了一遍，并且详细注释了每一步的作用，还做了下简单的速度对比。目前有：冒泡排序、选择排序、插入排序、希尔排序、快速排序、归并排序、堆排序，后续会考虑更新些不常用的排序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399package com.konb.heap;import java.util.Arrays;import java.util.Random;/** * @author konb * @version 1.0 * @date 2022-05-05 9:43 * 把几个常用的算法自己手写一遍，加深印象 */public class Sort &#123; /** * 冒泡排序 升序 这个没啥好说的，最简单也非常慢,到1000差距就已经很明显了，可以考虑优化 * @param a */ public static void bubbleSort(int[] a) &#123; for (int i = a.length - 1; i &gt; 0; i --) &#123; boolean isChange = false; for (int j = 0; j &lt; i; j ++) &#123; if (a[j] &gt; a[j + 1]) &#123; isChange = true; int temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; &#125; &#125; //优化：判断一轮结束后是否发生交换，如果没有则说明有序直接退出 if (! isChange) &#123; break; &#125; &#125; &#125; /** * 选择排序 升序 仅仅是比冒泡排序好 * @param a */ public static void selectionSort(int[] a) &#123; for (int i = 0; i &lt; a.length - 1; i ++) &#123; //记录最小值，默认遍历的第一个值 int min = a[i]; //记录每次最小值的下标 int minIndex = i; for (int j = i + 1; j &lt; a.length; j ++) &#123; if (a[j] &lt; min) &#123; min = a[j]; minIndex = j; &#125; &#125; //交换当前无序的第一个值和最小值 int temp = a[i]; a[i] = min; a[minIndex] = temp; &#125; &#125; /** * 快速排序 升序 经测试该方法比quick_sort（网上找的）更快 * * @param a 待排序数组 */ public static void quickSort(int[] a, int left, int right) &#123; //当前数组需要进行排序的长度 int length = right - left; //如果排序的数组长度小于2就不需要排了 if (length &lt; 2) &#123; return; &#125; //确定当前基准值，以当前数组的第一个值作为基准 int pivot = a[left]; //记录当前基准值的位置 int pivotIndex = left; //遍历当前数组，将小于基准值的值移动到其左边 for (int i = left + 1; i &lt; right; i ++) &#123; if (a[i] &lt; pivot) &#123; //将小于基准的值覆盖基准值的位置，并把基准值的位置+1,这样小于基准值的值就移动到基准值的左边 a[pivotIndex] = a[i]; pivotIndex ++; //把基准值下一位的值覆盖i上的值 a[i] = a[pivotIndex]; &#125; &#125; //将基准值覆盖此时基准值的位置 a[pivotIndex] = pivot; //继续排序基准值左边的数组 quickSort(a, left, pivotIndex); //继续排序基准值右边的数组 quickSort(a, pivotIndex + 1, right); &#125; /** * 插入排序 升序 测试效率很低，100万级就不行了，比快排慢多了，应该是因为有很多无用的比较 * @param a */ public static void insertSort(int[] a) &#123; //从1开始遍历数组，该位置之前的数组是有序的，初始有序数组长度为1 for (int i = 1; i &lt; a.length; i ++) &#123; //拿到需要进行插入的值，和有序数组的每个值进行对比 int temp = a[i]; //拿到即将要和插入的值进行比较的值的下标，初始为有序数组的第一个元素 int j = i - 1; //遍历数组有序部分 for (; j &gt;= 0; j --) &#123; //升序，如果小于，则交换，即将当前遍历到的有序数组的值往后移一位 if (temp &lt; a[j]) &#123; a[j + 1] = a[j]; &#125; else&#123; break; &#125; &#125; //插入的位置 a[j + 1] = temp; &#125; &#125; /** * 希尔排序 升序 实际就是插入排序的优化版，测试速度比插入排序快很多，在20万数据以前和快速排序（quick_sort)差不多，10万以内的数据 * 和快速排序（quickSort）差不多，但是在20万以后，就比快速排序慢，100万以后差距就比较明显了 * @param a */ public static void shellSort(int[] a) &#123; //获取数组长度 int length = a.length; //获取间隙，初始为数组长度除以2 int gap = length / 2; //循环分组插入排序 while (gap &gt; 0) &#123; //遍历每一组 for (int i = 0; i &lt; gap; i ++) &#123; //对当前组进行插入排序，这部分和插入排序时一样的，只不过插入排序每次是加1，希尔排序每次是gap for (int j = i + gap; j &lt; length; j += gap) &#123; int k = j - gap; int temp = a[j]; for (; k &gt;= 0; k -= gap) &#123; if (temp &lt; a[k]) &#123; a[k + gap] = a[k]; &#125; else &#123; break; &#125; &#125; a[k + gap] = temp; &#125; &#125; //对所有组都进行一次排序后，减少间隙，重新分组并排序 gap /= 2; &#125; &#125; /** * 归并排序 升序 100万级速度和希尔排序相近，比快排慢，1000万级相对来说速度非常快，远超希尔和快排，可能这就是Java底层在数据量较少的情况下用快速排序，较多的情况下用归并排序的原因 * @param a */ public static void mergeSort(int[] a, int left, int right) &#123; //判断是否可再分 if (left &lt; right) &#123; //获取中间值 int mid = (right + left) / 2; //递归左半部分 mergeSort(a, left, mid); //递归右半部分 mergeSort(a, mid + 1, right); //合并 merge(a, left, mid, right); &#125; &#125; /** * 归并排序的合并 * @param a * @param left * @param mid * @param right */ private static void merge(int[] a, int left, int mid, int right) &#123; //获取临时数组长度 int length = right - left + 1; //临时数组，保存当前部分排序后的结果 int[] temp = new int[length]; //左边最大值小于右边最小值则已经是有序，不需要再排序 if (a[mid] &lt;= a[mid + 1]) &#123; return; &#125; //临时数组下标 int k = 0; //如果左边最小值大于右边最大值，则需要把左右两部分反转 if (a[left] &gt; a[right]) &#123; for (int i = mid + 1; i &lt;= right; i ++) &#123; temp[k ++] = a[i]; &#125; for (int i = left; i &lt;= mid; i ++) &#123; temp[k ++] = a[i]; &#125; //其他情况，对比左右两边，判断最小值放入临时数组 &#125; else &#123; //左半部分下标 int i = left; //右半部分下标 int j = mid + 1; while (i &lt;= mid) &#123; while (j &lt;= right) &#123; //左半部分的值更小 if (a[i] &lt;= a[j] &amp;&amp; i &lt;= mid) &#123; temp[k ++] = a[i ++]; //右半部分的值更小 &#125; else &#123; temp[k ++] = a[j ++]; &#125; &#125; //右半部分遍历完，左半部分还没有遍历完的话，直接追加到临时数组后面 if (i &lt;= mid) &#123; temp[k ++] = a[i ++]; &#125; &#125; &#125; //将临时数组的值更新到目标排序数组 for(int i = left; i &lt;= right; i ++) &#123; a[i] = temp[i - left]; &#125; &#125; /** * 堆排序，使用最大堆升序 10万级速度很快，超过快排，100万级以上比希尔快，比归并和快排慢 * @param a */ public static void heapSort(int[] a) &#123; //构建最大堆，从最后一个有子节点的节点开始，最后一个有子节点的节点的下标 = (length -2) / 2 for (int i = (a.length - 2) / 2; i &gt;= 0; i --) &#123; downAdjust(a, i, a.length); &#125; //最大堆的堆顶即为该堆的最大值，每次将堆定替换数组最后一个数，然后下沉 for (int i = a.length - 1; i &gt;= 0; i --) &#123; int temp = a[i]; a[i] = a[0]; a[0] = temp; downAdjust(a, 0, i); &#125; &#125; /** * 构建最大堆，下沉 * @param a * @param parentIndex * @param length */ private static void downAdjust(int[] a, int parentIndex, int length) &#123; //保存根节点的值 int temp = a[parentIndex]; /** * 将二叉堆层序遍历到数组后可以发现如下关系 * 左子节点的下标 = 父节点下标 * 2 + 1 * 右子节点的下标 = 父节点下标 * 2 + 2 */ int childIndex = parentIndex * 2 + 1; //遍历子节点 while (childIndex &lt; length) &#123; //如果有右子节点且右子节点比左子节点更大，则替换成右子节点 if (childIndex + 1 &lt; length &amp;&amp; a[childIndex + 1] &gt; a[childIndex]) &#123; childIndex ++; &#125; //如果根节点比左右子节点都大，则不需要下沉，直接退出 if (temp &gt; a[childIndex]) &#123; break; &#125; /** * 如果根节点比子节点小，则将子节点覆盖根节点， * 并且继续判断子节点的子节点，这里不需要替换而是覆盖， * 是因为前面保存了最开始的根节点的值 */ a[parentIndex] = a[childIndex]; parentIndex = childIndex; childIndex = parentIndex * 2 + 1; &#125; //将当前的根节点即最后一个对比的有效子节点替换为最开始的根节点，有这一步前面就不需要交换 a[parentIndex] = temp; &#125; /** * 网上找的快排，比我写的快排效率稍差， 我的思路是参考这个，这个是双指针，我的是单指针 * @param num * @param l * @param r * @return */ public static int[] quick_sort(int[] num, int l, int r) &#123; //r为数组元素总个数，last下标等于r-1 int first = l, last = r - 1, key = num[first]; while (first &lt; last) &#123; while (first &lt; last &amp;&amp; num[last] &gt;= key) &#123; --last; &#125; //如果值小于 key分界值 交换 num[first] = num[last]; while (first &lt; last &amp;&amp; num[first] &lt; key) &#123; ++first; &#125; //如果值大于key分界值 交换 num[last] = num[first]; &#125; num[first] = key; //递归左右部分进行快排 if (first &gt; l) &#123; num = quick_sort(num, l, first); &#125; if (first + 1 &lt; r) &#123; num = quick_sort(num, first + 1, r); &#125; return num; &#125; //[11, 10, 9, 7, 7, 6, 6, 5, 3, 1] public static void main(String[] args) &#123; Random random = new Random(); int[] array1 = new int[100000]; for (int i = 0; i &lt;100000; i ++) &#123; array1[i] = random.nextInt(1000); &#125; int[] array2 = Arrays.copyOf(array1, array1.length); int[] array3 = Arrays.copyOf(array1, array1.length); int[] array4 = Arrays.copyOf(array1, array1.length); int[] array5 = Arrays.copyOf(array1, array1.length); int[] array6 = Arrays.copyOf(array1, array1.length); int[] array7 = Arrays.copyOf(array1, array1.length); //System.out.println(Arrays.toString(array1)); //System.out.println(&quot;---------------------------------------&quot;);// long time5 = System.currentTimeMillis();// insertSort(array3);// long time6 = System.currentTimeMillis();// System.out.println(Arrays.toString(array3));// System.out.println(&quot;插入排序耗时：&quot; + (time6 - time5)); long time7 = System.currentTimeMillis(); shellSort(array4); long time8 = System.currentTimeMillis(); //System.out.println(Arrays.toString(array4)); System.out.println(&quot;希尔排序耗时：&quot; + (time8 - time7)); long time13 = System.currentTimeMillis(); heapSort(array7); long time14 = System.currentTimeMillis(); //System.out.println(Arrays.toString(array7)); System.out.println(&quot;堆排序耗时：&quot; + (time14 - time13)); long time9 = System.currentTimeMillis(); mergeSort(array5, 0, array5.length - 1); long time10 = System.currentTimeMillis(); //System.out.println(Arrays.toString(array5)); System.out.println(&quot;归并排序耗时：&quot; + (time10 - time9));// long time11 = System.currentTimeMillis();// selectionSort(array6);// long time12 = System.currentTimeMillis();// //System.out.println(Arrays.toString(array6));// System.out.println(&quot;选择排序耗时：&quot; + (time12 - time11));// long time3 = System.currentTimeMillis();// bubbleSort(array2);// long time4 = System.currentTimeMillis();// //System.out.println(Arrays.toString(array2));// System.out.println(&quot;冒泡排序耗时：&quot; + (time4 - time3)); long time1 = System.currentTimeMillis(); quickSort(array1, 0, array1.length); long time2 = System.currentTimeMillis(); //System.out.println(Arrays.toString(array1)); System.out.println(&quot;快排（自己）耗时：&quot; + (time2 - time1)); &#125;&#125;","path":"2022/05/06/common-sort-algorithms/","date":"05-06","excerpt":"","tags":[{"name":"排序算法","slug":"排序算法","permalink":"https://konb-hui.github.io/blog/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}]},{"title":"SpringBoot启动流程的超详细解析（下）","text":"继续接着上篇文章讲SpringBoot的启动流程，这篇是真正开始分析启动的完整过程。 123456@SpringBootApplicationpublic class WjApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(WjApplication.class, args); &#125;&#125; 一、创建SpringApplication对象首先进入SpringApplication.run方法，最终发现是执行如下代码，new了一个SpringApplication对象，并且执行它的run方法。 123public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) &#123; return (new SpringApplication(primarySources)).run(args);&#125; 再看下SpringApplication的构造函数，发现主要是对成员变量做了些初始化的操作，后面会进一步介绍它们的作用。 123456789101112public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) &#123; //资源加载器，默认为null this.resourceLoader = resourceLoader; Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;); this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources)); //Web应用程序类型，通过判断是否存在某些类来确定类型 this.webApplicationType = WebApplicationType.deduceFromClasspath(); this.bootstrappers = new ArrayList&lt;&gt;(getSpringFactoriesInstances(Bootstrapper.class)); setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); this.mainApplicationClass = deduceMainApplicationClass();&#125; 二、执行run方法进入实例化SpringApplication对象的run方法，如下代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445public ConfigurableApplicationContext run(String... args) &#123; //秒表，计时的，SpringBoot启动完成后能看到一个时间，就是这个 StopWatch stopWatch = new StopWatch(); stopWatch.start(); //加载上下文 DefaultBootstrapContext bootstrapContext = createBootstrapContext(); ConfigurableApplicationContext context = null; //设置java.awt.headless 模式，是一种配置模式，在系统缺少了显示设备、键盘或鼠标时可以使用该模式。 configureHeadlessProperty(); //获取程序运行监听器，并且执行 SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(bootstrapContext, this.mainApplicationClass); try &#123; //将main函数的参数封装到ApplicationArguments，为后面的prepareEnvironment提供参数 ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); //准备environment ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments); configureIgnoreBeanInfo(environment); Banner printedBanner = printBanner(environment); context = createApplicationContext(); context.setApplicationStartup(this.applicationStartup); prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner); refreshContext(context); afterRefresh(context, applicationArguments); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch); &#125; listeners.started(context); callRunners(context, applicationArguments); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, listeners); throw new IllegalStateException(ex); &#125; try &#123; listeners.running(context); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, null); throw new IllegalStateException(ex); &#125; return context;&#125; 1.初始化上下文12345 //初始化上下文//启动上下文 DefaultBootstrapContext bootstrapContext = this.createBootstrapContext();//配置上下文 ConfigurableApplicationContext context = null; DefaultBootstrapContext继承了BootstrapRegistry和BootstrapContext分别用于注册和提供注册过的需要在应用上下文加载完成前使用的类的实例。看下启动上下文bootstrapContext的创建方法createBootstrapContext源码。 注：实际DefaultBootstrapContext是实现了ConfigurableBootstrapContext，而ConfigurableBootstrapContext继承了BootstrapRegistry和BootstrapContext 12345678910private DefaultBootstrapContext createBootstrapContext() &#123; //new一个DefaultBootstrapContext对象 DefaultBootstrapContext bootstrapContext = new DefaultBootstrapContext(); //遍历bootstrappers并执行intitialize方法 this.bootstrappers.forEach((initializer) -&gt; &#123; initializer.intitialize(bootstrapContext); &#125;); //返回DefaultBootstrapContext对象 return bootstrapContext;&#125; 我们看下最开始SpringApplication的构造函数可以发现bootstrappers是通过this.getSpringFactoriesInstances(Bootstrapper.class)来获取的，我们看下源码。 1234567891011private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args) &#123; //获取类加载器 ClassLoader classLoader = this.getClassLoader(); //获取META-INF/spring.factories文件中Bootstrapper类型的类的全限定名 Set&lt;String&gt; names = new LinkedHashSet(SpringFactoriesLoader.loadFactoryNames(type, classLoader)); //通过上步获取的全限定名生成实例 List&lt;T&gt; instances = this.createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names); //排序 AnnotationAwareOrderComparator.sort(instances); return instances;&#125; （1）获取类加载器判断resourceLoader资源加载器是否为null，不是则用它的类加载器，否则是默认的加载器，从SpringApplication的构造函数可以发现当前的资源加载器是null，所以是使用默认的类加载器。 123public ClassLoader getClassLoader() &#123; return this.resourceLoader != null ? this.resourceLoader.getClassLoader() : ClassUtils.getDefaultClassLoader();&#125; 123public SpringApplication(Class&lt;?&gt;... primarySources) &#123; this((ResourceLoader)null, primarySources);&#125; （2）加载全限定名可以看下loadFactoryNames的源码loadFactoryNames调用了loadSpringFactories方法，我们可以看到这个方法就是去获取META-INF/spring.factories中的类名，前面也说过这个文件也是SpringBoot自动加载的核心。 12345/** * The location to look for factories. * &lt;p&gt;Can be present in multiple JAR files. */public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;; 1234567891011121314151617181920212223242526272829303132public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryType, @Nullable ClassLoader classLoader) &#123; ClassLoader classLoaderToUse = classLoader; if (classLoaderToUse == null) &#123; classLoaderToUse = SpringFactoriesLoader.class.getClassLoader(); &#125; String factoryTypeName = factoryType.getName(); return loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());&#125;private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(ClassLoader classLoader) &#123;... try &#123; //获取META-INF/spring.factories中的类名 Enumeration&lt;URL&gt; urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION); while (urls.hasMoreElements()) &#123; URL url = urls.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123; String factoryTypeName = ((String) entry.getKey()).trim(); String[] factoryImplementationNames = StringUtils.commaDelimitedListToStringArray((String) entry.getValue()); for (String factoryImplementationName : factoryImplementationNames) &#123; result.computeIfAbsent(factoryTypeName, key -&gt; new ArrayList&lt;&gt;()) .add(factoryImplementationName.trim()); &#125; &#125; &#125;...&#125; （3）创建实例看下createSpringFactoriesInstances源码。很简单，就是通过反射的方式获取实例。 12345678910111213141516171819private &lt;T&gt; List&lt;T&gt; createSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, ClassLoader classLoader, Object[] args, Set&lt;String&gt; names) &#123; List&lt;T&gt; instances = new ArrayList&lt;&gt;(names.size()); for (String name : names) &#123; try &#123; Class&lt;?&gt; instanceClass = ClassUtils.forName(name, classLoader); Assert.isAssignable(type, instanceClass); //通过反射获取构造方法 Constructor&lt;?&gt; constructor = instanceClass.getDeclaredConstructor(parameterTypes); //通过获取的构造方法创建实例 T instance = (T) BeanUtils.instantiateClass(constructor, args); instances.add(instance); &#125; catch (Throwable ex) &#123; throw new IllegalArgumentException(&quot;Cannot instantiate &quot; + type + &quot; : &quot; + name, ex); &#125; &#125; return instances;&#125; 2.执行程序运行监听器123 //获取程序运行监听器，并且执行SpringApplicationRunListeners listeners = getRunListeners(args);listeners.starting(bootstrapContext, this.mainApplicationClass); 首先看下getRunListeners方法的代码SpringApplicationRunListeners的作用就是让用户可以在SpringBoot启动时在各个阶段可以加入自己的代码逻辑。 12345678private SpringApplicationRunListeners getRunListeners(String[] args) &#123; Class&lt;?&gt;[] types = new Class&lt;?&gt;[] &#123; SpringApplication.class, String[].class &#125;; //创建并返回一个SpringApplicationRunListeners对象 return new SpringApplicationRunListeners(logger, //这个方法上面见过了，获取META-INF/spring.factories中SpringApplicationRunListener类型的实例 getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args), this.applicationStartup);&#125; 简单看下SpringApplicationRunListeners的代码，可以看到主要有一下阶段。 1234567891011121314//当run()方法开始执行时就调用void starting(ConfigurableBootstrapContext bootstrapContext, Class&lt;?&gt; mainApplicationClass) &#123;&#125;//当environment构建完成，ApplicationContext创建之前，该方法被调用void environmentPrepared(ConfigurableBootstrapContext bootstrapContext, ConfigurableEnvironment environment) &#123;&#125;// 当ApplicationContext构建完成时，该方法被调用void contextPrepared(ConfigurableApplicationContext context) &#123;&#125;// 在ApplicationContext完成加载，但没有被刷新前，该方法被调用void contextLoaded(ConfigurableApplicationContext context) &#123;&#125;// 在ApplicationContext刷新并启动后，CommandLineRunners和ApplicationRunner未被调用前，该方法被调用void started(ConfigurableApplicationContext context) &#123;&#125;// 在run()方法执行完成前该方法被调用void running(ConfigurableApplicationContext context) &#123;&#125;// 当应用运行出错时该方法被调用void failed(ConfigurableApplicationContext context, Throwable exception) &#123;&#125; 再看下第二行代码，执行listeners的start方法,有一个mainApplicationClass成员变量，在一开始的构造函数里有赋值操作，调用了deduceMainApplicationClass方法，看下它的源码。所以它返回了main函数所在类的全限定名，在这个例子就是com.konb.wj.WjApplication。然后start方法上面也说了，当run()方法开始执行时就调用。 12345678910111213141516private Class&lt;?&gt; deduceMainApplicationClass() &#123; try &#123; //获取方法调用栈的信息 StackTraceElement[] stackTrace = new RuntimeException().getStackTrace(); for (StackTraceElement stackTraceElement : stackTrace) &#123; //匹配main方法 if (&quot;main&quot;.equals(stackTraceElement.getMethodName())) &#123; return Class.forName(stackTraceElement.getClassName()); &#125; &#125; &#125; catch (ClassNotFoundException ex) &#123; // Swallow and continue &#125; return null;&#125; 3.准备environment准备environment环境用了一行代码，主要操作都在prepareEnvironment方法中，看下该方法的源码。 12//准备environmentConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments); 123456789101112131415161718private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners, DefaultBootstrapContext bootstrapContext, ApplicationArguments applicationArguments) &#123; // 根据当前web程序类型获取environment ConfigurableEnvironment environment = getOrCreateEnvironment(); //配置environment configureEnvironment(environment, applicationArguments.getSourceArgs()); ConfigurationPropertySources.attach(environment); listeners.environmentPrepared(bootstrapContext, environment); DefaultPropertiesPropertySource.moveToEnd(environment); configureAdditionalProfiles(environment); bindToSpringApplication(environment); if (!this.isCustomEnvironment) &#123; environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment, deduceEnvironmentClass()); &#125; ConfigurationPropertySources.attach(environment); return environment;&#125; （1）获取environment首先看下getOrCreateEnvironment的源码 123456789101112131415private ConfigurableEnvironment getOrCreateEnvironment() &#123; //判断environment是否已创建 if (this.environment != null) &#123; return this.environment; &#125; //根据当前web程序类型，获取对应的environment，webApplicationType的值已经在前面构造函数中调用deduceFromClasspath获取了 switch (this.webApplicationType) &#123; case SERVLET: return new StandardServletEnvironment(); case REACTIVE: return new StandardReactiveWebEnvironment(); default: return new StandardEnvironment(); &#125;&#125; （2）配置environment看下configureEnvironment的源码 12345678910111213protected void configureEnvironment(ConfigurableEnvironment environment, String[] args) &#123; //addConversionService由前面代码可知初始化是true if (this.addConversionService) &#123; //获取转化服务，用于Object对象之间的类型转换；getSharedInstance获取单例，是通过双重校验锁实现的单例 ConversionService conversionService = ApplicationConversionService.getSharedInstance(); //添加转化服务 environment.setConversionService((ConfigurableConversionService) conversionService); &#125; //配置environment中的propertysources configurePropertySources(environment, args); //配置profiles，当前2.4.3该方法是空的，不知道为啥 configureProfiles(environment, args);&#125; 看下configurePropertySources的源码 123456789101112131415161718192021protected void configurePropertySources(ConfigurableEnvironment environment, String[] args) &#123; //获取当前环境的属性源 MutablePropertySources sources = environment.getPropertySources(); //判断this.defaultProperties（初始化为空）是否为空，不为空则加到sources DefaultPropertiesPropertySource.ifNotEmpty(this.defaultProperties, sources::addLast); //判断是否有命令行属性，有的话就增加 if (this.addCommandLineProperties &amp;&amp; args.length &gt; 0) &#123; String name = CommandLinePropertySource.COMMAND_LINE_PROPERTY_SOURCE_NAME; if (sources.contains(name)) &#123; PropertySource&lt;?&gt; source = sources.get(name); CompositePropertySource composite = new CompositePropertySource(name); composite.addPropertySource( new SimpleCommandLinePropertySource(&quot;springApplicationCommandLineArgs&quot;, args)); composite.addPropertySource(source); sources.replace(name, composite); &#125; else &#123; sources.addFirst(new SimpleCommandLinePropertySource(args)); &#125; &#125;&#125;","path":"2022/04/12/springboot-detailed-explanation/springboot-detailed-explanation-2/","date":"04-12","excerpt":"","tags":[{"name":"spring","slug":"spring","permalink":"https://konb-hui.github.io/blog/tags/spring/"},{"name":"springboot","slug":"springboot","permalink":"https://konb-hui.github.io/blog/tags/springboot/"}]},{"title":"SpringBoot启动流程的超详细解析（上）","text":"最近想了解下SpringBoot启动流程，网上看了些博客，但是一般都很简单，看得我云里雾里，所以决定自己一行一行分析源码，目标是尽可能知道每一行代码的作用。 首先看下启动类，如下代码，一个main方法，很简单，主要是两部分，@SpringBootApplication注解和SpringApplication调用的run()方法。 123456@SpringBootApplicationpublic class WjApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(WjApplication.class, args); &#125;&#125; 上篇先讲下@SpringBootApplication注解，首先也看下源代码，然后一行行分析。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123; @AliasFor( annotation = EnableAutoConfiguration.class ) Class&lt;?&gt;[] exclude() default &#123;&#125;; @AliasFor( annotation = EnableAutoConfiguration.class ) String[] excludeName() default &#123;&#125;; @AliasFor( annotation = ComponentScan.class, attribute = &quot;basePackages&quot; ) String[] scanBasePackages() default &#123;&#125;; @AliasFor( annotation = ComponentScan.class, attribute = &quot;basePackageClasses&quot; ) Class&lt;?&gt;[] scanBasePackageClasses() default &#123;&#125;; @AliasFor( annotation = ComponentScan.class, attribute = &quot;nameGenerator&quot; ) Class&lt;? extends BeanNameGenerator&gt; nameGenerator() default BeanNameGenerator.class; @AliasFor( annotation = Configuration.class ) boolean proxyBeanMethods() default true;&#125; 1.@Target(&#123;ElementType.TYPE&#125;)这个注解属于Java基础内容，一个数组元素，看注释说：返回注释类型可以应用于的元素种类的数组，因此这个注释就是用于指定@SpringBootApplication注解可添加到的类型。 123456789101112@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Target &#123; /** * Returns an array of the kinds of elements an annotation type * can be applied to. * @return an array of the kinds of elements an annotation type * can be applied to */ ElementType[] value();&#125; &#123;ElementType.TYPE&#125;数组，只有一个元素，看下ElementType的源码，总共有10种，最后2种是JDK1.8新增的，然后TYPE类型，看注释可知用于Class, interface (including annotation type), enum。而我们上面的WjApplication就是Class类型。 123456789101112131415161718192021222324252627282930313233343536373839public enum ElementType &#123; /** Class, interface (including annotation type), or enum declaration */ TYPE, /** Field declaration (includes enum constants) */ FIELD, /** Method declaration */ METHOD, /** Formal parameter declaration */ PARAMETER, /** Constructor declaration */ CONSTRUCTOR, /** Local variable declaration */ LOCAL_VARIABLE, /** Annotation type declaration */ ANNOTATION_TYPE, /** Package declaration */ PACKAGE, /** * Type parameter declaration * * @since 1.8 */ TYPE_PARAMETER, /** * Use of a type * * @since 1.8 */ TYPE_USE&#125; 2.@Retention(RetentionPolicy.RUNTIME)该注解还是Java基础，看注释，返回一个保留策略，也就是说指定当前被修饰的注解会被保留多久 12345678910@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Retention &#123; /** * Returns the retention policy. * @return the retention policy */ RetentionPolicy value();&#125; 看下参数RetentionPolicy源码，总共3中类型，RUNTIME看注释：注解会被编译器记录在Class文件中，运行时也会被虚拟机保存，可以通过反射获取。这种类型是保留时间最长的，和普通的类是一样的。 123456789101112131415161718192021public enum RetentionPolicy &#123; /** * Annotations are to be discarded by the compiler. */ SOURCE, /** * Annotations are to be recorded in the class file by the compiler * but need not be retained by the VM at run time. This is the default * behavior. */ CLASS, /** * Annotations are to be recorded in the class file by the compiler and * retained by the VM at run time, so they may be read reflectively. * * @see java.lang.reflect.AnnotatedElement */ RUNTIME&#125; 3.@Documented还是Java基础，添加这个注解后生成javadoc的时候会被记录。 12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Documented &#123;&#125; 4.@Inherited看名字就可以知道，添加该注解后，注释会被自动继承，也就是说，如果有一个类继承了WjApplication，那么这个类也会带@SpringBootApplication注解。 12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Inherited &#123;&#125; 5.@SpringBootConfiguration这个注解是SpringBoot特有的，主要分析@Configuration和@AliasFor注解。 12345678910@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Configurationpublic @interface SpringBootConfiguration &#123; @AliasFor( annotation = Configuration.class ) boolean proxyBeanMethods() default true;&#125; （1）@AliasFor由@Target(&#123;ElementType.METHOD&#125;)可知该注解用于方法上。该注解主要有两个功能，添加别名和组合注解。 123456789101112@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.METHOD&#125;)@Documentedpublic @interface AliasFor &#123; @AliasFor(&quot;attribute&quot;) String value() default &quot;&quot;; @AliasFor(&quot;value&quot;) String attribute() default &quot;&quot;; Class&lt;? extends Annotation&gt; annotation() default Annotation.class;&#125; a.添加别名如下代码，path和value属性都互为别名，也就是说在使用这个注解的时候，参数写value = xx或者path = xx的效果是一样的。 注意： 互为别名的属性属性值类型，默认值，都是相同的； 互为别名的注解必须成对出现，比如 value 属性添加了@AliasFor(&quot;path&quot;)，那么 path 属性就必须添加@AliasFor(&quot;calue&quot;)； 另外还有一点，互为别名的属性必须定义默认值。 1234567891011121314@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Mappingpublic @interface RequestMapping &#123; String name() default &quot;&quot;; @AliasFor(&quot;path&quot;) String[] value() default &#123;&#125;; @AliasFor(&quot;value&quot;) String[] path() default &#123;&#125;; ...&#125; b.组合注解如下代码，设置annotation = ComponentScan.class和attribute = &quot;basePackages&quot;就代表给@ComponentScan注解的basePackages属性设置scanBasePackages别名，这样就可以加多个注解组合成一个注解。 123456789101112...@AliasFor( annotation = EnableAutoConfiguration.class)String[] excludeName() default &#123;&#125;;@AliasFor( annotation = ComponentScan.class, attribute = &quot;basePackages&quot;)String[] scanBasePackages() default &#123;&#125;;... （2）@Configuration用于定义一个配置类，同时也是一个bean，因为有@Component注解。 123456789101112@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Configuration &#123; @AliasFor( annotation = Component.class ) String value() default &quot;&quot;; boolean proxyBeanMethods() default true;&#125; @Component注解，看下代码，该注解用于声明当前类作为Spring容器的bean 1234567@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Indexedpublic @interface Component &#123; String value() default &quot;&quot;;&#125; @Indexed源码，这个注解简单来讲就是能给bean生成索引，提高SpringBoot启动时扫描bean文件的速度。它是如何提高的以后有机会再分析。 12345@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Indexed &#123;&#125; 6.@EnableAutoConfiguration12345678910111213@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123; String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;; Class&lt;?&gt;[] exclude() default &#123;&#125;; String[] excludeName() default &#123;&#125;;&#125; 看下官方API文档的介绍，第一句话就介绍了这个注解的作用：通过用户配置的classpath自动加载可能需要的bean。 ENABLED_OVERRIDE_PROPERTY ： 环境参数，当自动配置被启动时可以被重写。 exclude ：设置不需要自动配置的类 excludeName ：设置不需要自动配置的类名 （1）@AutoConfigurationPackage注册自动扫描的包，如果没有声明基础包路径，则以当前注解所在的包作为自动扫描的包 basePackages：字符串数组，设置基础包路径 basePackageClasses：Class数组，设置基础包路径 12345678910@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Import(&#123;Registrar.class&#125;)public @interface AutoConfigurationPackage &#123; String[] basePackages() default &#123;&#125;; Class&lt;?&gt;[] basePackageClasses() default &#123;&#125;;&#125; （2）@Import用于导入一些配置类，功能同Spring的xml文件配置中的&lt;import&gt;标签，Spring提供三种方式让类可以被import，被import的类会生成bean被Spring容器管理。 带@Configuration注解的类（4.2版本后也可以是普通类） 继承ImportSelector接口 继承ImportBeanDefinitionRegistrar接口 123456@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Import &#123; Class&lt;?&gt;[] value();&#125; 了解了@Import，再稍微了解下前面@EnableAutoConfiguration引入的AutoConfigurationImportSelector.class和@AutoConfigurationPackage引入的Registrar.class AutoConfigurationImportSelector.class：该类主要的作用是加载META-INF/spring.factories中的bean到容器中，后面在介绍SpringBoot自动加载原理的时候再详细分析。 Registrar.class：该类为org.springframework.boot.autoconfigure.AutoConfigurationPackages类的一个内部类AutoConfigurationPackages官方文档解释为：保存自动配置类以供使用。Registrar的作用是批量注册某一个包下的所有组件。 123456789101112131415public abstract class AutoConfigurationPackages &#123; ... static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123; Registrar() &#123; &#125; public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123; AutoConfigurationPackages.register(registry, (String[])(new AutoConfigurationPackages.PackageImports(metadata)).getPackageNames().toArray(new String[0])); &#125; public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123; return Collections.singleton(new AutoConfigurationPackages.PackageImports(metadata)); &#125; &#125;&#125; 这样，SpringBoot启动类的注解就简单的分析完了，基本上是和SpringBoot的自动配置有关，SpringBoot的自动配置后面会详细分析原理。下一篇文章将会分析启动类的main方法。","path":"2022/04/06/springboot-detailed-explanation/springboot-detailed-explanation-1/","date":"04-06","excerpt":"","tags":[{"name":"spring","slug":"spring","permalink":"https://konb-hui.github.io/blog/tags/spring/"},{"name":"springboot","slug":"springboot","permalink":"https://konb-hui.github.io/blog/tags/springboot/"}]},{"title":"静态方法中使用spring管理的bean","text":"【任务标题】静态方法中使用spring管理的bean 【状态】已解决 【任务奖励】银币 * 2 【要求时间】1 Day 【委托人】村民C 【任务详情】请提供方法能够在静态方法中调用被spring容器管理的类 【承接人】konb 【解决过程】如下代码示例，解决的步骤如下 添加一个当前类的静态属性serverManager 添加要使用的被spring管理的对象属性messageService 创建被@PostConstruct修饰的initServerManager()方法，对serverManager对象赋值，值（this)为当前类被new后的对象 调用需要的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.spm.study.demoproject.area.soft.server;import com.alibaba.fastjson.JSON;import com.spm.study.demoproject.area.soft.Service.basic.NormalMessageService;import com.spm.study.demoproject.area.soft.Service.notice.MessageService;import com.spm.study.demoproject.area.soft.entity.T_USER;import com.spm.study.demoproject.area.soft.entity.basic.NormalMessage;import com.spm.study.demoproject.area.soft.entity.notice.ChangeBatch;import com.spm.study.demoproject.area.soft.entity.notice.Message;import com.spm.study.demoproject.area.soft.util.SessionUtil;import com.spm.study.demoproject.area.soft.util.basic.MessageEnum;import com.spm.study.demoproject.area.soft.util.manual.ManualConstant;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import javax.annotation.PostConstruct;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.concurrent.ConcurrentHashMap;/** * @author konb */@Componentpublic class ServerManager &#123; //3.@PostConstruct修饰非静态的void方法，保证该方法会在构造函数之后，init()方法之前执行 @PostConstruct public void initServerManager() &#123; serverManager = this; &#125; //2.添加要使用的被spring管理的对象属性 @Autowired private MessageService messageService; @Autowired private NormalMessageService normalMessageService; private static Map&lt;Integer, WebSocketServer&gt; servers = new ConcurrentHashMap&lt;&gt;(); //1.添加当前类的静态属性 public static ServerManager serverManager; public static void broadCast(String msg)&#123; &#125; public static int getTotal()&#123; return servers.size(); &#125; public static Map&lt;Integer, WebSocketServer&gt; getServers()&#123; return servers; &#125; public static void sendNoticeInformation(Integer userId, String message, ChangeBatch changeBatch) &#123; WebSocketServer webSocketServer = servers.get(userId); Message msg = new Message(); msg.setContent(message); msg.setToUser(userId); msg.setBatch(changeBatch.getBatch()); msg.setCid(changeBatch.getId()); //4.调用messageService serverManager.messageService.save(msg); if (webSocketServer != null) &#123; webSocketServer.sendMessage(message); &#125; &#125; public static void remove(WebSocketServer server) &#123; servers.remove(server.getUserId()); &#125; public static void remove(Integer userId) &#123; servers.remove(userId); &#125; /** * 查询当前用户是否在线 * @param userId 用户ID * @return boolean */ public static boolean isOnline(Integer userId) &#123; return servers.get(userId) != null; &#125;&#125;","path":"2022/03/25/side-quest/2/static-method-use-bean-20220325/","date":"03-25","excerpt":"","tags":[{"name":"spring","slug":"spring","permalink":"https://konb-hui.github.io/blog/tags/spring/"}]},{"title":"解决创建maven项目的报错","text":"【任务标题】解决创建maven项目的报错 【状态】已解决 【任务奖励】铜币 * 50 【要求时间】马上 【委托人】村民A 【任务详情】昨天晚上我在使用idea创建maven项目的时候，初始化项目的时候报了如下错，初始化失败没有生成src文件，在idea使用maven的其他操作，如clean均会报这个错。 【承接人】konb 【解决过程】通过命令提示符直接执行mvn clean发现如下错误，可以看出是setting.xml配置文件出错了。 经过观察配置文件发现注释符号少了一半，这个其实也很坑，由于这个注释符号后面又紧接着一个注释，很难发现少了一半，因为notepad++还是会把这部分标绿，显示成注释的状态。加回另一半注释符号完美运行。","path":"2022/03/24/side-quest/1/maven-create-error-20220324/maven-create-error-20220324/","date":"03-24","excerpt":"","tags":[{"name":"maven","slug":"maven","permalink":"https://konb-hui.github.io/blog/tags/maven/"}]},{"title":"如何搭建个人博客","text":"简单记录下自己博客的搭建过程。 一、准备环境1.下载node JS,安装2.打开控制台安装cnpm1npm install -g cnpm --registry=https://registry.npm.taobao.org 3.安装Hexo(用于搭建博客的工具)1cnpm install hexo-cli -g 4.下载git，版本控制工具，点击前往安装教程，需要配合GitHub或者Gitee账号使用二、本地创建博客项目1.新建一个文件夹用于保存项目文件，进入文件夹，右键选择如下图 2.点击后需要输入自己的邮箱和密码，若完成git安装教程应该已经保存邮箱和密码3.输入hexo init，初始化仓库，稍加等待4.输入hexo s，然后在浏览器输入localhost:4000，已经可以访问默认的博客5.点击前往 , 选择自己喜欢的主题,如下为选择主题后下载的一个示例git clone https://github.com/ZEROKISEKI/hexo-theme-gal.git themes/gal 6.输入如下命令下载必要插件，注意需要安装python ，建议安装2.7版本，本人因为安装的是3.7的版本导致一直报错，后来切换2.7版本解决123cnpm install hexo-renderer-sass --savecnpm install hexo-renderer-scss --savecnpm install hexo-generator-json-content --save 7.使用文本编辑器打开如下文件并进行编辑，在末尾添加如下文本（若使用的不是示例中的主题，请忽略这步）123456789101112131415161718192021jsonContent: dateFormat: MM-DD pages: title: true text: true path: true date: true excerpt: true preview: true posts: title: true text: true path: true date: true excerpt: true tags: [&#123; name: tag.name, slug: tag.slug, permalink: tag.permalink &#125;] preview: true 8.切换下载的主题，如下图所示，修改为自己要切换的主题 9.输入如下命令，创建某些常用页面，更多Hexo命令点击前往1234# 开启搜索功能hexo new page &quot;search&quot;# 配置错误页面hexo new page &quot;404&quot; 10.再次执行hexo s,启动博客，此时该指令可能无效，原因是Hexo 3.0 把服务器独立成了个别模块，必须先安装 hexo-server 才能使用1$ npm install hexo-server --save 11.开始创建和编写自己的文章，文章都是markdown文件，建议使用Typora,点击前往下载测试版（正式版需要付费），提取码pn5v12.编写完成后，执行hexo g，再hexo s重新启动三、部署到Github1.在Github上创建一个仓库 2.选择SSH链接，因为现在Github已经不支持在其他地方使用账号和密码登录 3.修改_config.yml文件，将root修改为和创建的仓库的名字一致，repo输入你自己的SSH地址，type和branch如下图所示 4.输入hexo g5.安装hexo部署插件1cnpm install --save hexo-deployer-git 6.输入hexo d进行部署7.刷新Github仓库，进入Settings-&gt;pages,选择branch，再save成功则生成博客地址","path":"2022/03/22/construction-personal-blog/construction-personal-blog/","date":"03-22","excerpt":"","tags":[]},{"title":"聊聊Java虚拟机的类加载机制","text":"学过Java的都知道.java文件需要通过编译变成.class文件才能运行，那么Java虚拟机是如何把这些Class文件进行加载和运行的呢？ 一、介绍一个类从被加载进内存直到被从内存中卸载，整个生命周期主要包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）、卸载（Unloading）七个阶段。其中验证、准备、解析又可以总称为连接（Linking）。每个步骤的发生顺序见下图。 加载、验证、准备、初始化、卸载五个阶段是固定的，不过这个固定指的是开始的时间，实际上它们一般是交叉进行的。在某些情况，解析可能在初始化之后开始，为了支持Java语言的运行时绑定（动态绑定）。 二、类加载的过程2.1 加载加载阶段虚拟机将会执行如下3件事： 通过一个类的全限定名来获取定义此类的二进制字节流； 将这个字节流所代表的静态存储结构转换为方法区运行时数据结构； 在Java堆生成一个代表该类的Java.lang.Class对象，作为方法区数据的访问入口。 针对于第一件事，虚拟机规范并没有指明字节流要从那里获取和怎样获取。很多Java技术都建立在这一基础上，例如： 从ZIP包中读取，最终成为日后JAR、EAR、WAR格式的基础 从网络中获取 运行时动态生成，即动态代理 由其他文件生成，如JSP 从数据库读取，有些中间件服务器可以选择把程序安装到数据库中来完成程序代码在集群间的分布 2.2 验证为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自生的安全。大致分为四个阶段：文件格式验证、元数据验证、字节码验证和符号引用验证。 （1）文件格式验证用于验证Class文件的格式是否符合规范，可能包括以下部分： 是否以魔数0xCAFFBABY开头 主、次版本是否在当前虚拟机可处理范围内 常量池的常量是否有不被支持的类型 指向常量的各种索引值是否由指向不存在的常量或者不符合类型的常量 CONSTANT_Utf8_info型的常量师傅有不符合UTF8编码的数据 Class文件中各个部分及文件本身是否有被删除的或附加的其他信息 上面部分只是截取HotSpot虚拟机源码的一小部分。经过该阶段的验证后，字节流才会进入内存的方法区进行存储。 （2）元数据验证对字节码描述的信息进行语义分析，保证符合Java语言规范。 （3）字节码验证进行数据流和控制流的分析，对类的方法体进行校验分析，保证该类的方法在运行时不会做出危害虚拟机安全的行为。例如： 保证任意时刻操作数栈的数据类型与指令代码序列都可以配合工作。不会出现类似放置了一个int类型，却使用long类型来加载 保证指令跳转不会跳转到方法体以外的指令上去 保证方法体重的类型转发是有效的。例如子类可以赋值给父类，但父类不可以赋值给子类 （4）符号引用验证对类自身以外（常量池中的各种符号引用）的信息进行匹配性的校验。 2.3 准备该阶段为类变量（static修饰的变量）分配内存并设置类变量初始值。 基本数据类型的零值 2.4 解析解析过程就是虚拟机将常量池中的符号引用替换为直接引用的过程。 符号引用：以一组符号来描述引用的对象，该符号可以是任何字面量，只要能够保证无歧义的定位到目标即可。符号引用与虚拟机实现的内存布局没有关系，不要求目标一定已加载到内存中。 直接引用：可以是直接指向目标的指针、相对偏移量或者一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机翻译出来的直接引用一般不同。如果存在直接引用，那么目标必然已经存在内存中。 解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行。 2.5 初始化该阶段是类加载过程的最后一步，会根据程序员定制的计划去初始化类变量和其他资源。 三、类加载器3.1 介绍绝大部分Java程序都会使用到以下三种系统提供的类加载器 启动类加载器（Bootstrap ClassLoader）：负责将存放在&lt;JAVA_HOME&gt;\\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。该加载器无法被Java程序直接引用。 扩展类加载器（Extension ClassLoader）：有sun.misc.Launcher$ExtClassLoader实现，它负责加载&lt;JAVA_HOME&gt;\\lib\\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中所有类库。可以直接使用扩展类加载器。 应用程序类加载器（Application ClassLoader）：由sun.misc.Launcher$AppClassLoader来实现。该加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以也被称作系统类加载器。负责加载用户类路径上所指定的类库，可以直接使用该加载器，且如果开发者没有自定义过类加载器，默认都是使用该加载器。 3.2 双亲委派原则如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每个层次的类加载器都是如此，因此所有的加载请求最终都应该加载到顶层的启动类加载器中，只有当父类加载器反馈无法完成这个加载请求时，子加载器才会尝试自己去加载。保证Java类随着它的加载器一起具备了一种带有优先级的层次关系。","path":"2022/01/01/class-loading-mechanism/class-loading-mechanism/","date":"01-01","excerpt":"","tags":[]},{"title":"设计模式系列：单例模式","text":"单例模式是最简单的设计模式之一，不过也是非常常用的一种创建型的设计模式。 一、介绍 目的：保证一个类只有一个实例，防止一个全局使用的类频繁的创建和销毁。 优点： 在内存中只有一个实例，减少内存的开销，尤其是在频繁创建和销毁实例的时候 避免资源的多重占用 缺点：没有接口，不能继承，违反单一职责原则 案例： 数据库连接池、线程池等各种池 spring的单例模式的bean的生成和使用 平常代码中设置为全局的一些属性的保存 二、实现方式单例模式有多种实现方式，主要有六种 1、懒汉式，线程不安全单例模式的特点就是不允许外部创建。这种方式是最简单的一种实现方式，并且也满足了懒加载，在需要使用到这个类时才进行实例化，但是没有加锁，线程不安全，在多线程的情况下会出现被多次实例化的情况。 1234567891011public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 2、懒汉式，线程安全相对于上一种只是加了个synchronized关键字，不过已经能够保证线程安全了，但是效率非常低，我们大部分情况是不需要同步的，只有在new的时候才需要。 12345678910public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 3、饿汉式该方式利用static关键字的特性，在程序运行的时候即加载，后续直接获取，在不加锁的情况下实现了线程安全，但不属于懒加载，浪费内存 1234567public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 4、双检锁/双重校验锁（DCL，即 double-checked locking）该方法使用了volatile关键字，关于该关键字的介绍请点击这里，然后就是对方法上的锁进行了优化，减少了部分获取实例的耗时，并且满足了懒加载 1234567891011121314public class Singleton &#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125; 5、CAS「AtomicReference」(线程安全) java并发库提供了很多原子类来支持并发访问的数据安全性；AtomicInteger、AtomicBoolean、AtomicLong、AtomicReference。 CAS在不加锁的情况下，能够保证一定程度的并发性，缺点也很明显，要是并发量特别大，可能某一个线程一直在死循环 1234567891011121314151617181920public class Singleton &#123; private static final AtomicReference&lt;Singleton&gt; INSTANCE = new AtomicReference&lt;Singleton&gt;(); private static Singleton instance; private Singleton() &#123; &#125; public static final Singleton getInstance() &#123; for (; ; ) &#123; Singleton instance = INSTANCE.get(); if (null != instance) return instance; INSTANCE.compareAndSet(null, new Singleton()); return INSTANCE.get(); &#125; &#125;&#125; 6、枚举单例这种方式是《Effective Java》的作者推荐的，不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。 其他单例模式一旦继承Serializable接口（继承该接口表示可进行序列化和反序列化），就不再是单例了，每次调用readObject()方法都是返回一个新创建的对象 对于枚举类型，Java做了特殊规定，在序列化的时候仅仅是将枚举对象的name属性输出，反序列化时通过java.lang.Enum的valueOf()方法来根据名字查找对象 通过反编译可以知道enum的属性都是被static修饰的，所以能够保证线程安全 注：序列化和反序列化主要用于对象在网络中的传输 简单示例： 12345public enum Singleton &#123; INSTANCE; public void whateverMethod() &#123; &#125; &#125; 具体示例： 12345678910111213141516public class Singleton &#123; private Singleton()&#123;&#125; static enum SingletonEnum &#123; INSTANCE; private Singleton singleton; private SingletonEnum() &#123; singleton = new Singleton(); &#125; public Singleton getInstance() &#123; return singleton; &#125; &#125;&#125;","path":"2021/12/31/design-pattern/singleton-mode/singleton-mode/","date":"12-31","excerpt":"","tags":[]},{"title":"JDK常用小工具","text":"简单介绍一下JDK中bin目录下的一些常用工具，主要是参照《深入理解Java虚拟机：JVM高级特性与最佳实践》一书，感兴趣的可以去购买该书。 一、JDK命令行工具1.jps （JVM Process Status Tool）: 虚拟机进程状况工具用于列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class，main()函数所在的类）的名称，以及这些进程的本地虚拟机的唯一ID（LVMID，Local Virtual Machine Identifier）。对于本地虚拟机进程来说，LVMID与操作系统的进程ID（PID， Process Identifier）是一致的。 命令格式： 1jps [ options ] [ hostid ] 2.jstat （JVM Statistics Monitoring Tool）: 虚拟机统计信息监视工具用于监视虚拟机各种运行状态信息。可以显示本地或远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据，是运行期间定位虚拟机性能问题的首选工具。 命令格式： 1jstat [ option vmid [interval[s|ms] [count]] ] jstat工具主要选项： 3.jinfo（Configuration Info for Java） : Java配置信息工具用于实时查看和调整虚拟机的各项参数 命令格式 1jinfo [ option ] pid 4.jmap（Memory Map for Java） : 内存映像工具用于生成堆转存快照（一般称为heapdump或dump文件）。也可以查询finalize执行队列，Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。 命令格式： 1jmap [ option ] vmid jmap工具主要选项 5.jhat（JVM Heap Analysis Tool）: 虚拟机堆转储快照分析工具用于分析jmap生成的堆转储快照 6.jstack（Stack Trace for Java） : Java堆栈跟踪工具用于生成虚拟机当前时刻的线程快照（一般称为threaddump或javacore文件）。生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程之间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。 线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。 命令格式： 1jstack [ option ] vmid jstack工具的主要选项 二、JDK可视化工具1.JConsole（Java Monitoring and Management Console）: Java监视与管理控制台(1) 启动JConsole启动JConsole后，将自动搜索出本机运行的所以虚拟机进程，不需要再使用jps来查询了。 进入JConsole主界面，可以看到主界面共包括“概述”、“内存”、“线程”、“类”、“VM概要”和“MBean”六个页签，如下图所示。 概述页签显示的是整个虚拟机主要运行数据的概述，包括”堆内存使用情况“、”线程“、”类“、”CPU使用情况“四项信息的曲线图。 (2) 内存监控“内存”页签相当于可视化的jstat命令，用于监视受收集器管理的虚拟机内存（Java堆和永久代（JDK1.8以后改为元空间了））的变化趋势。 (3) 线程监控“线程”页签的功能相当于可视化的jstack命令，遇到线程停顿的时候可以使用这个页签进行监控分析。 2.VisualVM（All-in-One Java Troubleshooting Tool） : 多合一故障处理工具除了拥有运行监视、故障处理的功能外，还拥有很多其他方面的功能。如性能分析（Profiling），而且VisualVM还有一个很大的优点：不需要被监视的程序基于特殊Agent运行，因此它对应用程序的实际性能的影响很小，使得它可以直接应用在生产环境中。这个优点是JProfiler、YourKit等工具无法与之媲美的。 (1) 插件安装VisualVM精华的功能在于可以安装插件。在有网络的情况下，点击“工具”–&gt;“插件”菜单，弹出如下图所示的插件页签，在页签的“可用插件”中列举了当前版本VisualVM可以使用的插件，选中插件后在右边窗口将显示插件的基本信息，如开发者、版本、功能描述等。 VisualVM的“概述”、“监视”、“线程”、“MBeans”的功能和前面介绍的JConsole差别不大。 (2) 生成和浏览堆转储快照在VisualVM中生成dump文件有两种方式 a.在“应用程序”窗口中右键单击应用程序节点，然后选择“堆Dump”； b.在“应用程序”窗口中双击应用程序节点以打开应用程序标签，然后在“监视”标签总单击“堆Dump”。 生成dump文件后，应用程序页签将在该堆的应用程序下增加一个子节点，如下图所示。如需保存或者发送，需要在该节点上右键选择“另存为”菜单，否则VisualVM关闭时会被当做临时文件删除。要打开一个dump文件，通过文件菜单中的“装入”功能，选择对应的dump文件即可。 (3) 分析程序性能在Profiler页签中，VisualVM提供了程序运行期间方法级的CPU执行时间分析及内存分析，进行分析会对程序运行性能产生较大的影响，一般不在生产环境中使用该项功能 开始分析前，先选择“CPU”和“内存”按钮中的一个，然后切换到应用程序中进行操作，VisualVM会记录这段时间中应用程序执行过的方法。如果是CPU分析，将会统计每个方法的执行次数、执行耗时；如果是内存分析则会统计每个方法关联的对象数及所占空间。 (4) BTrace动态日志跟踪BTrace能在不停止目标程序运行的情况下，通过HotSpot虚拟机的HotSwap技术动态加入原本并不存在的调试代码。在安装BTrace插件后，应用程序面板右键点击要调试的程序，会出现“Trace Application”菜单，点击进入BTrace面板。","path":"2021/12/26/JDK-common-gadgets/JDK-common-gadgets/","date":"12-26","excerpt":"","tags":[]},{"title":"记一次文件切片上传文件损坏的bug","text":"今天碰到一个文件损坏的bug。从系统下载之前上传的PDF文件，打开时会提示文件损坏，实际使用浏览器和WPS可以正常打开，使用Adobe Acrobat会提示文件已损坏。下面简单记录下整个bug的解决过程。 产生bug的功能是自己写的文件切片上传，基本过程是从前端将大于2M的文件拆分成数个最大2M的文件，然后将所有切片上传到后端，前端上传完所有切片会发一个消息告诉后端开始将所有切片合成原文件，后端合成完后再将文件的下载地址返回给前端。 1.首先从服务器上面copy下来上传的文件和原文件对比从下图可以看出，上传后的文件的大小比原文件更大了，大了1017个字节，现在需要确认是在前端拆分的时候生成的文件变大了还是在后端文件合成的时候变大了 2.修改代码保留后端上传的临时文件，查看临时文件的大小是否正常 经观察发现，所有文件的字节数之和等于生成后的上传文件的字节数，2097152 * 10 + 890880 = 21862400，所以不是文件合成导致的 3.打印前端上传的切片文件，发现所有切片文件的字节数之和等于原文件的字节数之和，2097152 * 10 + 889683 = 21861383，所以可以确定，只有小于2M的切片被变大了，且是在前端文件上传后，后端文件合成前被变大的。 4.查看代码发现，在切片文件上传后，都有一个文件转存的过程，经过查看文件转存的代码，发现了小于2M的切片文件变大的原因。转存时由于代码的逻辑问题导致文件的部分字节被重复写了一次原代码: 123456789101112131415161718192021/** * 将上传的文件保存到新文件中 * @param uploadFile 上传的文件 MultipartFile * @param saveFile 新保存的文件 */public static void copyUploadFile(MultipartFile uploadFile, File saveFile) &#123; byte[] data = new byte[1024]; try(InputStream inputStream = uploadFile.getInputStream(); BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream); OutputStream outputStream = new FileOutputStream(saveFile); BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(outputStream)) &#123; //当文件剩余的部分小于1024个字节时，data中不足1024的部分仍是上一个1024个字节的部分，直接write就导致那部分重新写了 while (bufferedInputStream.read(data) &gt; 0) &#123; bufferedOutputStream.write(data); bufferedOutputStream.flush(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); throw new SrsException(300, &quot;文件读取失败&quot;); &#125;&#125; 修改后的代码： 12345678910111213141516171819202122/** * 将上传的文件保存到新文件中 * @param uploadFile 上传的文件 MultipartFile * @param saveFile 新保存的文件 */public static void copyUploadFile(MultipartFile uploadFile, File saveFile) &#123; byte[] data = new byte[1024]; try(InputStream inputStream = uploadFile.getInputStream(); BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream); OutputStream outputStream = new FileOutputStream(saveFile); BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(outputStream)) &#123; int len = -1; while ((len = bufferedInputStream.read(data)) != -1) &#123; //只写新读取到的字节数，不把1024个字节都写进去 bufferedOutputStream.write(data, 0, len); bufferedOutputStream.flush(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); throw new SrsException(300, &quot;文件读取失败&quot;); &#125;&#125;","path":"2021/12/15/记一次文件切片上传文件损坏的bug/记一次文件切片上传文件损坏的bug/","date":"12-15","excerpt":"","tags":[]},{"title":"资源分享","text":"","path":"2021/12/11/资源分享/资源分享/","date":"12-11","excerpt":"","tags":[]}],"categories":[],"tags":[{"name":"chatGPT","slug":"chatGPT","permalink":"https://konb-hui.github.io/blog/tags/chatGPT/"},{"name":"[object Object]","slug":"object-Object","permalink":"https://konb-hui.github.io/blog/tags/object-Object/"},{"name":"成神之路","slug":"成神之路","permalink":"https://konb-hui.github.io/blog/tags/%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/"},{"name":"排序算法","slug":"排序算法","permalink":"https://konb-hui.github.io/blog/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"spring","slug":"spring","permalink":"https://konb-hui.github.io/blog/tags/spring/"},{"name":"springboot","slug":"springboot","permalink":"https://konb-hui.github.io/blog/tags/springboot/"},{"name":"maven","slug":"maven","permalink":"https://konb-hui.github.io/blog/tags/maven/"}]}