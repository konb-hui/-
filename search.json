[{"title":"如何创建一个chatGPT的微信机器人","date":"2023-03-22T11:39:41.000Z","url":"/blog/2023/03/22/chatgpt-to-wechat/chatgpt-to-wechat/","tags":[["chatGPT","/blog/tags/chatGPT/"]],"categories":[["成神之路","/blog/categories/%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/"]],"content":"最近chatGPT还是比较火，也因为也比较感兴趣且刚好在github上看到一个把chatGPT做出微信机器人的项目，然后就去了解了下怎么弄，然后就出了这个教程把整个过程总结一下。 一、准备api key1.注册openAI账号 准备一个邮箱 需要代理或者VPN才能进入官网注册，而且需要是chatGPT支持的国家 需要一个国外的手机号，也需要是chatGPT支持的国家，可以去这里购买，也需要注册，支持支付宝，一次至少充值1美元，1美元最便宜的可以买两个号码，不过一定要先确认好chatGPT支不支持该国家 -以上都准备好了，就可以直接注册了，然后此时可以直接去这里体验官网的chatGPT，如果想继续创建自己的应用就往下 2.创建api key点击这里创建api key，如下图所示 二、创建应用1.使用github项目该项目是nodeJS，fork或者直接拉到本地都行，如果想部署在外网就fork，部署本地就拉到本地，不过都需要准备好代理地址该项目默认提供了两种方式，如下图 chatgpt就是连接到chatGPT3.5，也是我们目前的目的，不过他用的不是官网的接口，也是一个GitHub的开源项目，该项目提供了两种接口，对比如下 第一种是收费的，1000token/0.002美元,这种也是我们目前用的，因为注册openAI会送18美元，所以个人可以用很久了第二种免费的，但是用这个项目下的代理会封号，第一个失效，第二个很慢且会被封号，亲身经历 openAI是官网提供的另一个AI模型，没有chatGPT强也挺不错了，且不需要代理，可以直接使用 2.修改代码因为是调的接口，即使运行应用的机器跑了代理也不会起效，所以我们要修改请求方式，修改为如下代码就行 当然也可以使用官方提供的接口，去该地址, 官方提供了三种方式，不过需要自己探索代理请求的方法 为了保证chatGPT可以理解上下文进行对话，需要带上每次请求接口返回的id,代码如下所示，response是chatGPT的回复 3.修改配置这个参照该项目的readme文件就好 4.部署 本地部署，很简单，参照作者的教程就好 外网部署，这里我一定要推荐railway,该网站可以使用github登录，然后直接选择自己仓库的项目就可以一键部署，每个月会送5美元，个人使用完全足够了，没有域名的，部署完成后记得点击setting的这个地方生成一个域名，这个虽然简单，但是部署外网有风险，因为api key暴露在外网，要小心被被人薅了羊毛 三、备用 微信使用程序自动回复，会有风险被封号，切记使用小号，切记使用小号，切记使用小号，且不要加太多人使用，否则容易被封，自己用应该问题不大， 备用方案是用网站，我目前还在开发一个双服务器的网站版的系统，一个外网java服务器进行消息转发，一个nodeJS服务器在本地请求chatGPT，前端就是一个聊天框，两个服务器通过websocket通信，这样可以让chatGPT的访问在本地，之前使用别人的web项目，不知道是因为代理地址的原因还是项目的原因，openAI账号被封了，这样是最安全的。 代码java服务器代码nodeJS服务器代码前端代码 "},{"title":"常用排序算法","date":"2022-05-06T07:27:00.000Z","url":"/blog/2022/05/06/common-sort-algorithms/","tags":[["排序算法","/blog/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"]],"categories":[["成神之路","/blog/categories/%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/"],["代码记录","/blog/categories/%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/%E4%BB%A3%E7%A0%81%E8%AE%B0%E5%BD%95/"]],"content":"因为一直来说没有去手写过这些排序算法，只是了解原理，所以将一些常用的算法自己手写了一遍，并且详细注释了每一步的作用，还做了下简单的速度对比。目前有：冒泡排序、选择排序、插入排序、希尔排序、快速排序、归并排序、堆排序，后续会考虑更新些不常用的排序。 "},{"title":"SpringBoot启动流程的超详细解析（下）","date":"2022-04-12T02:33:52.000Z","url":"/blog/2022/04/12/springboot-detailed-explanation/springboot-detailed-explanation-2/","tags":[["spring","/blog/tags/spring/"],["springboot","/blog/tags/springboot/"]],"categories":[["成神之路","/blog/categories/%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/"],["源码分析","/blog/categories/%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"]],"content":"继续接着上篇文章讲SpringBoot的启动流程，这篇是真正开始分析启动的完整过程。 一、创建SpringApplication对象首先进入SpringApplication.run方法，最终发现是执行如下代码，new了一个SpringApplication对象，并且执行它的run方法。 再看下SpringApplication的构造函数，发现主要是对成员变量做了些初始化的操作，后面会进一步介绍它们的作用。 二、执行run方法进入实例化SpringApplication对象的run方法，如下代码 1.初始化上下文 DefaultBootstrapContext继承了BootstrapRegistry和BootstrapContext分别用于注册和提供注册过的需要在应用上下文加载完成前使用的类的实例。看下启动上下文bootstrapContext的创建方法createBootstrapContext源码。 注：实际DefaultBootstrapContext是实现了ConfigurableBootstrapContext，而ConfigurableBootstrapContext继承了BootstrapRegistry和BootstrapContext 我们看下最开始SpringApplication的构造函数可以发现bootstrappers是通过this.getSpringFactoriesInstances(Bootstrapper.class)来获取的，我们看下源码。 （1）获取类加载器判断resourceLoader资源加载器是否为null，不是则用它的类加载器，否则是默认的加载器，从SpringApplication的构造函数可以发现当前的资源加载器是null，所以是使用默认的类加载器。 （2）加载全限定名可以看下loadFactoryNames的源码loadFactoryNames调用了loadSpringFactories方法，我们可以看到这个方法就是去获取META-INF/spring.factories中的类名，前面也说过这个文件也是SpringBoot自动加载的核心。 （3）创建实例看下createSpringFactoriesInstances源码。很简单，就是通过反射的方式获取实例。 2.执行程序运行监听器 首先看下getRunListeners方法的代码SpringApplicationRunListeners的作用就是让用户可以在SpringBoot启动时在各个阶段可以加入自己的代码逻辑。 简单看下SpringApplicationRunListeners的代码，可以看到主要有一下阶段。 再看下第二行代码，执行listeners的start方法,有一个mainApplicationClass成员变量，在一开始的构造函数里有赋值操作，调用了deduceMainApplicationClass方法，看下它的源码。所以它返回了main函数所在类的全限定名，在这个例子就是com.konb.wj.WjApplication。然后start方法上面也说了，当run()方法开始执行时就调用。 3.准备environment准备environment环境用了一行代码，主要操作都在prepareEnvironment方法中，看下该方法的源码。 （1）获取environment首先看下getOrCreateEnvironment的源码 （2）配置environment看下configureEnvironment的源码 看下configurePropertySources的源码 "},{"title":"SpringBoot启动流程的超详细解析（上）","date":"2022-04-06T01:57:54.000Z","url":"/blog/2022/04/06/springboot-detailed-explanation/springboot-detailed-explanation-1/","tags":[["spring","/blog/tags/spring/"],["springboot","/blog/tags/springboot/"]],"categories":[["成神之路","/blog/categories/%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/"],["源码分析","/blog/categories/%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"]],"content":"最近想了解下SpringBoot启动流程，网上看了些博客，但是一般都很简单，看得我云里雾里，所以决定自己一行一行分析源码，目标是尽可能知道每一行代码的作用。 首先看下启动类，如下代码，一个main方法，很简单，主要是两部分，@SpringBootApplication注解和SpringApplication调用的run()方法。 上篇先讲下@SpringBootApplication注解，首先也看下源代码，然后一行行分析。 1.@Target(&#123;ElementType.TYPE&#125;)这个注解属于Java基础内容，一个数组元素，看注释说：返回注释类型可以应用于的元素种类的数组，因此这个注释就是用于指定@SpringBootApplication注解可添加到的类型。 &#123;ElementType.TYPE&#125;数组，只有一个元素，看下ElementType的源码，总共有10种，最后2种是JDK1.8新增的，然后TYPE类型，看注释可知用于Class, interface (including annotation type), enum。而我们上面的WjApplication就是Class类型。 2.@Retention(RetentionPolicy.RUNTIME)该注解还是Java基础，看注释，返回一个保留策略，也就是说指定当前被修饰的注解会被保留多久 看下参数RetentionPolicy源码，总共3中类型，RUNTIME看注释：注解会被编译器记录在Class文件中，运行时也会被虚拟机保存，可以通过反射获取。这种类型是保留时间最长的，和普通的类是一样的。 3.@Documented还是Java基础，添加这个注解后生成javadoc的时候会被记录。 4.@Inherited看名字就可以知道，添加该注解后，注释会被自动继承，也就是说，如果有一个类继承了WjApplication，那么这个类也会带@SpringBootApplication注解。 5.@SpringBootConfiguration这个注解是SpringBoot特有的，主要分析@Configuration和@AliasFor注解。 （1）@AliasFor由@Target(&#123;ElementType.METHOD&#125;)可知该注解用于方法上。该注解主要有两个功能，添加别名和组合注解。 a.添加别名如下代码，path和value属性都互为别名，也就是说在使用这个注解的时候，参数写value = xx或者path = xx的效果是一样的。 注意： 互为别名的属性属性值类型，默认值，都是相同的； 互为别名的注解必须成对出现，比如 value 属性添加了@AliasFor(&quot;path&quot;)，那么 path 属性就必须添加@AliasFor(&quot;calue&quot;)； 另外还有一点，互为别名的属性必须定义默认值。 b.组合注解如下代码，设置annotation = ComponentScan.class和attribute = &quot;basePackages&quot;就代表给@ComponentScan注解的basePackages属性设置scanBasePackages别名，这样就可以加多个注解组合成一个注解。 （2）@Configuration用于定义一个配置类，同时也是一个bean，因为有@Component注解。 @Component注解，看下代码，该注解用于声明当前类作为Spring容器的bean @Indexed源码，这个注解简单来讲就是能给bean生成索引，提高SpringBoot启动时扫描bean文件的速度。它是如何提高的以后有机会再分析。 6.@EnableAutoConfiguration 看下官方API文档的介绍，第一句话就介绍了这个注解的作用：通过用户配置的classpath自动加载可能需要的bean。 ENABLED_OVERRIDE_PROPERTY ： 环境参数，当自动配置被启动时可以被重写。 exclude ：设置不需要自动配置的类 excludeName ：设置不需要自动配置的类名 （1）@AutoConfigurationPackage注册自动扫描的包，如果没有声明基础包路径，则以当前注解所在的包作为自动扫描的包 basePackages：字符串数组，设置基础包路径 basePackageClasses：Class数组，设置基础包路径 （2）@Import用于导入一些配置类，功能同Spring的xml文件配置中的&lt;import&gt;标签，Spring提供三种方式让类可以被import，被import的类会生成bean被Spring容器管理。 带@Configuration注解的类（4.2版本后也可以是普通类） 继承ImportSelector接口 继承ImportBeanDefinitionRegistrar接口 了解了@Import，再稍微了解下前面@EnableAutoConfiguration引入的AutoConfigurationImportSelector.class和@AutoConfigurationPackage引入的Registrar.class AutoConfigurationImportSelector.class：该类主要的作用是加载META-INF/spring.factories中的bean到容器中，后面在介绍SpringBoot自动加载原理的时候再详细分析。 Registrar.class：该类为org.springframework.boot.autoconfigure.AutoConfigurationPackages类的一个内部类AutoConfigurationPackages官方文档解释为：保存自动配置类以供使用。Registrar的作用是批量注册某一个包下的所有组件。 这样，SpringBoot启动类的注解就简单的分析完了，基本上是和SpringBoot的自动配置有关，SpringBoot的自动配置后面会详细分析原理。下一篇文章将会分析启动类的main方法。"},{"title":"静态方法中使用spring管理的bean","date":"2022-03-25T08:30:01.000Z","url":"/blog/2022/03/25/side-quest/2/static-method-use-bean-20220325/","tags":[["spring","/blog/tags/spring/"]],"categories":[["支线任务","/blog/categories/%E6%94%AF%E7%BA%BF%E4%BB%BB%E5%8A%A1/"],["Rank D","/blog/categories/%E6%94%AF%E7%BA%BF%E4%BB%BB%E5%8A%A1/Rank-D/"]],"content":"【任务标题】静态方法中使用spring管理的bean 【状态】已解决 【任务奖励】银币 * 2 【要求时间】1 Day 【委托人】村民C 【任务详情】请提供方法能够在静态方法中调用被spring容器管理的类 【承接人】konb 【解决过程】如下代码示例，解决的步骤如下 添加一个当前类的静态属性serverManager 添加要使用的被spring管理的对象属性messageService 创建被@PostConstruct修饰的initServerManager()方法，对serverManager对象赋值，值（this)为当前类被new后的对象 调用需要的方法 "},{"title":"解决创建maven项目的报错","date":"2022-03-24T01:59:18.000Z","url":"/blog/2022/03/24/side-quest/1/maven-create-error-20220324/maven-create-error-20220324/","tags":[["maven","/blog/tags/maven/"]],"categories":[["支线任务","/blog/categories/%E6%94%AF%E7%BA%BF%E4%BB%BB%E5%8A%A1/"],["Rank E","/blog/categories/%E6%94%AF%E7%BA%BF%E4%BB%BB%E5%8A%A1/Rank-E/"]],"content":"【任务标题】解决创建maven项目的报错 【状态】已解决 【任务奖励】铜币 * 50 【要求时间】马上 【委托人】村民A 【任务详情】昨天晚上我在使用idea创建maven项目的时候，初始化项目的时候报了如下错，初始化失败没有生成src文件，在idea使用maven的其他操作，如clean均会报这个错。 【承接人】konb 【解决过程】通过命令提示符直接执行mvn clean发现如下错误，可以看出是setting.xml配置文件出错了。 经过观察配置文件发现注释符号少了一半，这个其实也很坑，由于这个注释符号后面又紧接着一个注释，很难发现少了一半，因为notepad++还是会把这部分标绿，显示成注释的状态。加回另一半注释符号完美运行。 "},{"title":"如何搭建个人博客","date":"2022-03-22T14:08:07.640Z","url":"/blog/2022/03/22/construction-personal-blog/construction-personal-blog/","categories":[["成神之路","/blog/categories/%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/"]],"content":"简单记录下自己博客的搭建过程。 一、准备环境1.下载node JS,安装2.打开控制台安装cnpm 3.安装Hexo(用于搭建博客的工具) 4.下载git，版本控制工具，点击前往安装教程，需要配合GitHub或者Gitee账号使用二、本地创建博客项目1.新建一个文件夹用于保存项目文件，进入文件夹，右键选择如下图 2.点击后需要输入自己的邮箱和密码，若完成git安装教程应该已经保存邮箱和密码3.输入hexo init，初始化仓库，稍加等待4.输入hexo s，然后在浏览器输入localhost:4000，已经可以访问默认的博客5.点击前往 , 选择自己喜欢的主题,如下为选择主题后下载的一个示例git clone  themes/gal 6.输入如下命令下载必要插件，注意需要安装python ，建议安装2.7版本，本人因为安装的是3.7的版本导致一直报错，后来切换2.7版本解决 7.使用文本编辑器打开如下文件并进行编辑，在末尾添加如下文本（若使用的不是示例中的主题，请忽略这步） 8.切换下载的主题，如下图所示，修改为自己要切换的主题 9.输入如下命令，创建某些常用页面，更多Hexo命令点击前往 10.再次执行hexo s,启动博客，此时该指令可能无效，原因是Hexo 3.0 把服务器独立成了个别模块，必须先安装 hexo-server 才能使用 11.开始创建和编写自己的文章，文章都是markdown文件，建议使用Typora,点击前往下载测试版（正式版需要付费），提取码pn5v12.编写完成后，执行hexo g，再hexo s重新启动三、部署到Github1.在Github上创建一个仓库 2.选择SSH链接，因为现在Github已经不支持在其他地方使用账号和密码登录 3.修改_config.yml文件，将root修改为和创建的仓库的名字一致，repo输入你自己的SSH地址，type和branch如下图所示 4.输入hexo g5.安装hexo部署插件 6.输入hexo d进行部署7.刷新Github仓库，进入Settings-&gt;pages,选择branch，再save成功则生成博客地址"},{"title":"聊聊Java虚拟机的类加载机制","date":"2022-01-01T04:25:14.000Z","url":"/blog/2022/01/01/class-loading-mechanism/class-loading-mechanism/","categories":[["成神之路","/blog/categories/%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/"]],"content":"学过Java的都知道.java文件需要通过编译变成.class文件才能运行，那么Java虚拟机是如何把这些Class文件进行加载和运行的呢？ 一、介绍一个类从被加载进内存直到被从内存中卸载，整个生命周期主要包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）、卸载（Unloading）七个阶段。其中验证、准备、解析又可以总称为连接（Linking）。每个步骤的发生顺序见下图。 加载、验证、准备、初始化、卸载五个阶段是固定的，不过这个固定指的是开始的时间，实际上它们一般是交叉进行的。在某些情况，解析可能在初始化之后开始，为了支持Java语言的运行时绑定（动态绑定）。 二、类加载的过程2.1 加载加载阶段虚拟机将会执行如下3件事： 通过一个类的全限定名来获取定义此类的二进制字节流； 将这个字节流所代表的静态存储结构转换为方法区运行时数据结构； 在Java堆生成一个代表该类的Java.lang.Class对象，作为方法区数据的访问入口。 针对于第一件事，虚拟机规范并没有指明字节流要从那里获取和怎样获取。很多Java技术都建立在这一基础上，例如： 从ZIP包中读取，最终成为日后JAR、EAR、WAR格式的基础 从网络中获取 运行时动态生成，即动态代理 由其他文件生成，如JSP 从数据库读取，有些中间件服务器可以选择把程序安装到数据库中来完成程序代码在集群间的分布 2.2 验证为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自生的安全。大致分为四个阶段：文件格式验证、元数据验证、字节码验证和符号引用验证。 （1）文件格式验证用于验证Class文件的格式是否符合规范，可能包括以下部分： 是否以魔数0xCAFFBABY开头 主、次版本是否在当前虚拟机可处理范围内 常量池的常量是否有不被支持的类型 指向常量的各种索引值是否由指向不存在的常量或者不符合类型的常量 CONSTANT_Utf8_info型的常量师傅有不符合UTF8编码的数据 Class文件中各个部分及文件本身是否有被删除的或附加的其他信息 上面部分只是截取HotSpot虚拟机源码的一小部分。经过该阶段的验证后，字节流才会进入内存的方法区进行存储。 （2）元数据验证对字节码描述的信息进行语义分析，保证符合Java语言规范。 （3）字节码验证进行数据流和控制流的分析，对类的方法体进行校验分析，保证该类的方法在运行时不会做出危害虚拟机安全的行为。例如： 保证任意时刻操作数栈的数据类型与指令代码序列都可以配合工作。不会出现类似放置了一个int类型，却使用long类型来加载 保证指令跳转不会跳转到方法体以外的指令上去 保证方法体重的类型转发是有效的。例如子类可以赋值给父类，但父类不可以赋值给子类 （4）符号引用验证对类自身以外（常量池中的各种符号引用）的信息进行匹配性的校验。 2.3 准备该阶段为类变量（static修饰的变量）分配内存并设置类变量初始值。 基本数据类型的零值 2.4 解析解析过程就是虚拟机将常量池中的符号引用替换为直接引用的过程。 符号引用：以一组符号来描述引用的对象，该符号可以是任何字面量，只要能够保证无歧义的定位到目标即可。符号引用与虚拟机实现的内存布局没有关系，不要求目标一定已加载到内存中。 直接引用：可以是直接指向目标的指针、相对偏移量或者一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机翻译出来的直接引用一般不同。如果存在直接引用，那么目标必然已经存在内存中。 解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行。 2.5 初始化该阶段是类加载过程的最后一步，会根据程序员定制的计划去初始化类变量和其他资源。 三、类加载器3.1 介绍绝大部分Java程序都会使用到以下三种系统提供的类加载器 启动类加载器（Bootstrap ClassLoader）：负责将存放在&lt;JAVA_HOME&gt;\\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。该加载器无法被Java程序直接引用。 扩展类加载器（Extension ClassLoader）：有sun.misc.Launcher$ExtClassLoader实现，它负责加载&lt;JAVA_HOME&gt;\\lib\\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中所有类库。可以直接使用扩展类加载器。 应用程序类加载器（Application ClassLoader）：由sun.misc.Launcher$AppClassLoader来实现。该加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以也被称作系统类加载器。负责加载用户类路径上所指定的类库，可以直接使用该加载器，且如果开发者没有自定义过类加载器，默认都是使用该加载器。 3.2 双亲委派原则如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每个层次的类加载器都是如此，因此所有的加载请求最终都应该加载到顶层的启动类加载器中，只有当父类加载器反馈无法完成这个加载请求时，子加载器才会尝试自己去加载。保证Java类随着它的加载器一起具备了一种带有优先级的层次关系。 "},{"title":"设计模式系列：单例模式","date":"2021-12-31T09:11:35.000Z","url":"/blog/2021/12/31/design-pattern/singleton-mode/singleton-mode/","categories":[["成神之路","/blog/categories/%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/"],["设计模式","/blog/categories/%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"]],"content":"单例模式是最简单的设计模式之一，不过也是非常常用的一种创建型的设计模式。 一、介绍 目的：保证一个类只有一个实例，防止一个全局使用的类频繁的创建和销毁。 优点： 在内存中只有一个实例，减少内存的开销，尤其是在频繁创建和销毁实例的时候 避免资源的多重占用 缺点：没有接口，不能继承，违反单一职责原则 案例： 数据库连接池、线程池等各种池 spring的单例模式的bean的生成和使用 平常代码中设置为全局的一些属性的保存 二、实现方式单例模式有多种实现方式，主要有六种 1、懒汉式，线程不安全单例模式的特点就是不允许外部创建。这种方式是最简单的一种实现方式，并且也满足了懒加载，在需要使用到这个类时才进行实例化，但是没有加锁，线程不安全，在多线程的情况下会出现被多次实例化的情况。 2、懒汉式，线程安全相对于上一种只是加了个synchronized关键字，不过已经能够保证线程安全了，但是效率非常低，我们大部分情况是不需要同步的，只有在new的时候才需要。 3、饿汉式该方式利用static关键字的特性，在程序运行的时候即加载，后续直接获取，在不加锁的情况下实现了线程安全，但不属于懒加载，浪费内存 4、双检锁/双重校验锁（DCL，即 double-checked locking）该方法使用了volatile关键字，关于该关键字的介绍请点击这里，然后就是对方法上的锁进行了优化，减少了部分获取实例的耗时，并且满足了懒加载 5、CAS「AtomicReference」(线程安全) java并发库提供了很多原子类来支持并发访问的数据安全性；AtomicInteger、AtomicBoolean、AtomicLong、AtomicReference。 CAS在不加锁的情况下，能够保证一定程度的并发性，缺点也很明显，要是并发量特别大，可能某一个线程一直在死循环 6、枚举单例这种方式是《Effective Java》的作者推荐的，不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。 其他单例模式一旦继承Serializable接口（继承该接口表示可进行序列化和反序列化），就不再是单例了，每次调用readObject()方法都是返回一个新创建的对象 对于枚举类型，Java做了特殊规定，在序列化的时候仅仅是将枚举对象的name属性输出，反序列化时通过java.lang.Enum的valueOf()方法来根据名字查找对象 通过反编译可以知道enum的属性都是被static修饰的，所以能够保证线程安全 注：序列化和反序列化主要用于对象在网络中的传输 简单示例： 具体示例： "},{"title":"JDK常用小工具","date":"2021-12-26T06:47:27.000Z","url":"/blog/2021/12/26/JDK-common-gadgets/JDK-common-gadgets/","categories":[["成神之路","/blog/categories/%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/"]],"content":"简单介绍一下JDK中bin目录下的一些常用工具，主要是参照《深入理解Java虚拟机：JVM高级特性与最佳实践》一书，感兴趣的可以去购买该书。 一、JDK命令行工具1.jps （JVM Process Status Tool）: 虚拟机进程状况工具用于列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class，main()函数所在的类）的名称，以及这些进程的本地虚拟机的唯一ID（LVMID，Local Virtual Machine Identifier）。对于本地虚拟机进程来说，LVMID与操作系统的进程ID（PID， Process Identifier）是一致的。 命令格式： 2.jstat （JVM Statistics Monitoring Tool）: 虚拟机统计信息监视工具用于监视虚拟机各种运行状态信息。可以显示本地或远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据，是运行期间定位虚拟机性能问题的首选工具。 命令格式： jstat工具主要选项： 3.jinfo（Configuration Info for Java） : Java配置信息工具用于实时查看和调整虚拟机的各项参数 命令格式 4.jmap（Memory Map for Java） : 内存映像工具用于生成堆转存快照（一般称为heapdump或dump文件）。也可以查询finalize执行队列，Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。 命令格式： jmap工具主要选项 5.jhat（JVM Heap Analysis Tool）: 虚拟机堆转储快照分析工具用于分析jmap生成的堆转储快照 6.jstack（Stack Trace for Java） : Java堆栈跟踪工具用于生成虚拟机当前时刻的线程快照（一般称为threaddump或javacore文件）。生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程之间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的常见原因。 线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。 命令格式： jstack工具的主要选项 二、JDK可视化工具1.JConsole（Java Monitoring and Management Console）: Java监视与管理控制台(1) 启动JConsole启动JConsole后，将自动搜索出本机运行的所以虚拟机进程，不需要再使用jps来查询了。 进入JConsole主界面，可以看到主界面共包括“概述”、“内存”、“线程”、“类”、“VM概要”和“MBean”六个页签，如下图所示。 概述页签显示的是整个虚拟机主要运行数据的概述，包括”堆内存使用情况“、”线程“、”类“、”CPU使用情况“四项信息的曲线图。 (2) 内存监控“内存”页签相当于可视化的jstat命令，用于监视受收集器管理的虚拟机内存（Java堆和永久代（JDK1.8以后改为元空间了））的变化趋势。 (3) 线程监控“线程”页签的功能相当于可视化的jstack命令，遇到线程停顿的时候可以使用这个页签进行监控分析。 2.VisualVM（All-in-One Java Troubleshooting Tool） : 多合一故障处理工具除了拥有运行监视、故障处理的功能外，还拥有很多其他方面的功能。如性能分析（Profiling），而且VisualVM还有一个很大的优点：不需要被监视的程序基于特殊Agent运行，因此它对应用程序的实际性能的影响很小，使得它可以直接应用在生产环境中。这个优点是JProfiler、YourKit等工具无法与之媲美的。 (1) 插件安装VisualVM精华的功能在于可以安装插件。在有网络的情况下，点击“工具”–&gt;“插件”菜单，弹出如下图所示的插件页签，在页签的“可用插件”中列举了当前版本VisualVM可以使用的插件，选中插件后在右边窗口将显示插件的基本信息，如开发者、版本、功能描述等。 VisualVM的“概述”、“监视”、“线程”、“MBeans”的功能和前面介绍的JConsole差别不大。 (2) 生成和浏览堆转储快照在VisualVM中生成dump文件有两种方式 a.在“应用程序”窗口中右键单击应用程序节点，然后选择“堆Dump”； b.在“应用程序”窗口中双击应用程序节点以打开应用程序标签，然后在“监视”标签总单击“堆Dump”。 生成dump文件后，应用程序页签将在该堆的应用程序下增加一个子节点，如下图所示。如需保存或者发送，需要在该节点上右键选择“另存为”菜单，否则VisualVM关闭时会被当做临时文件删除。要打开一个dump文件，通过文件菜单中的“装入”功能，选择对应的dump文件即可。 (3) 分析程序性能在Profiler页签中，VisualVM提供了程序运行期间方法级的CPU执行时间分析及内存分析，进行分析会对程序运行性能产生较大的影响，一般不在生产环境中使用该项功能 开始分析前，先选择“CPU”和“内存”按钮中的一个，然后切换到应用程序中进行操作，VisualVM会记录这段时间中应用程序执行过的方法。如果是CPU分析，将会统计每个方法的执行次数、执行耗时；如果是内存分析则会统计每个方法关联的对象数及所占空间。 (4) BTrace动态日志跟踪BTrace能在不停止目标程序运行的情况下，通过HotSpot虚拟机的HotSwap技术动态加入原本并不存在的调试代码。在安装BTrace插件后，应用程序面板右键点击要调试的程序，会出现“Trace Application”菜单，点击进入BTrace面板。 "},{"title":"记一次文件切片上传文件损坏的bug","date":"2021-12-15T07:11:01.000Z","url":"/blog/2021/12/15/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%96%87%E4%BB%B6%E5%88%87%E7%89%87%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%8D%9F%E5%9D%8F%E7%9A%84bug/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%96%87%E4%BB%B6%E5%88%87%E7%89%87%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%8D%9F%E5%9D%8F%E7%9A%84bug/","categories":[["神秘事件","/blog/categories/%E7%A5%9E%E7%A7%98%E4%BA%8B%E4%BB%B6/"]],"content":"今天碰到一个文件损坏的bug。从系统下载之前上传的PDF文件，打开时会提示文件损坏，实际使用浏览器和WPS可以正常打开，使用Adobe Acrobat会提示文件已损坏。下面简单记录下整个bug的解决过程。 产生bug的功能是自己写的文件切片上传，基本过程是从前端将大于2M的文件拆分成数个最大2M的文件，然后将所有切片上传到后端，前端上传完所有切片会发一个消息告诉后端开始将所有切片合成原文件，后端合成完后再将文件的下载地址返回给前端。 1.首先从服务器上面copy下来上传的文件和原文件对比从下图可以看出，上传后的文件的大小比原文件更大了，大了1017个字节，现在需要确认是在前端拆分的时候生成的文件变大了还是在后端文件合成的时候变大了 2.修改代码保留后端上传的临时文件，查看临时文件的大小是否正常 经观察发现，所有文件的字节数之和等于生成后的上传文件的字节数，2097152 * 10 + 890880 = 21862400，所以不是文件合成导致的 3.打印前端上传的切片文件，发现所有切片文件的字节数之和等于原文件的字节数之和，2097152 * 10 + 889683 = 21861383，所以可以确定，只有小于2M的切片被变大了，且是在前端文件上传后，后端文件合成前被变大的。 4.查看代码发现，在切片文件上传后，都有一个文件转存的过程，经过查看文件转存的代码，发现了小于2M的切片文件变大的原因。转存时由于代码的逻辑问题导致文件的部分字节被重复写了一次原代码: 修改后的代码： "},{"title":"资源分享","date":"2021-12-11T08:05:05.000Z","url":"/blog/2021/12/11/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/%E8%B5%84%E6%BA%90%E5%88%86%E4%BA%AB/","categories":[["神秘宝藏","/blog/categories/%E7%A5%9E%E7%A7%98%E5%AE%9D%E8%97%8F/"]]}]